/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
#include "GUI_App.h"
#include "DIALOG.h"
#include "usb_device.h"
#include "math.h"
#include "main.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

char Value;
#define ID_WINDOW_0  (GUI_ID_USER + 0x00)
#define ID_BUTTON_0  (GUI_ID_USER + 0x04)
#define ID_BUTTON_1  (GUI_ID_USER + 0x05)
#define ID_BUTTON_2  (GUI_ID_USER + 0x06)
#define ID_BUTTON_3  (GUI_ID_USER + 0x07)
#define ID_TEXT_0  (GUI_ID_USER + 0x08)
#define ID_PROG_0  (GUI_ID_USER + 0x09)
#define ID_SLID_0  (GUI_ID_USER + 0x10)
#define ID_TEXT_1  (GUI_ID_USER + 0x11)
#define ID_IMAGE_0_IMAGE_0  0x00
#define ID_IMAGE_1_IMAGE_0  0x01
#define ID_IMAGE_2_IMAGE_0  0x02

// USER START (Optionally insert additional defines)
// USER END

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
/*********************************************************************
*
*       _acImage_0, "BMP", ID_IMAGE_0_IMAGE_0
*/
static const U8 _acImage_0[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

/*********************************************************************
*
*       _acImage_1, "BMP", ID_IMAGE_1_IMAGE_0
*/
static const U8 _acImage_1[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

/*********************************************************************
*
*       _acImage_2, "BMP", ID_IMAGE_2_IMAGE_0
*/
static const U8 _acImage_2[463] = {
  0x42, 0x4D, 0xCE, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x01, 0x00, 0x00, 0x12, 0x0B, 0x00, 0x00,
  0x12, 0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21,
  0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00,
  0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84,
  0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08,
  0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10,
  0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00,
  0x88, 0x42, 0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42,
  0x10, 0x84, 0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84,
  0x21, 0x08, 0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0x88, 0x42, 0x10, 0x84, 0x21, 0x08,
  0x40, 0x00, 0x84, 0x21, 0x08, 0x42, 0x10, 0x84, 0x40, 0x00, 0xC2, 0x10, 0x84, 0x21, 0x08, 0x42, 0x40, 0x00, 0xA1, 0x08, 0x42, 0x10, 0x84, 0x21, 0x40, 0x00, 0x90, 0x84, 0x21, 0x08, 0x42, 0x10, 0xC0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x00,
  0x00,
};

// USER START (Optionally insert additional static data)
// USER END

/*********************************************************************
*
*       _aDialogCreate
*/
/*
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 800, 480, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "INPUT", ID_BUTTON_0, 0, 0, 200, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "ATTACK", ID_BUTTON_1, 600, 0, 200, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "RELEASE", ID_BUTTON_2, 0, 400, 200, 80, 0, 0x0, 0 },
  { BUTTON_CreateIndirect, "THRESHOLD", ID_BUTTON_3, 600, 400, 200, 80, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "dB", ID_TEXT_0, 180, 120, 340, 32, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "dB", ID_TEXT_1, 180, 350, 340, 32, 0, 0x64, 0 },

  // USER START (Optionally insert additional widgets)
  // USER END
};

*/
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 800, 480, 0, 0x0, 0 },
  { TEXT_CreateIndirect, "dB", ID_TEXT_0, 170, 35, 340, 32, 0, 0x64, 0 },
  { TEXT_CreateIndirect, "dB", ID_TEXT_1, 170, 445, 340, 32, 0, 0x64, 0 },

  // USER START (Optionally insert additional widgets)
  // USER END
};


uint8_t i=0;
int add=1;
float level = 0;
TS_StateTypeDef TS_State;
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;

DAC_HandleTypeDef hdac;
uint32_t adc1, adc2,avAdc1,lineStart,lineEnd;
uint32_t DMA_buffin[20];
uint32_t DMA_buffer[21];

uint8_t buffin[255],x;
uint32_t y = 240;
uint8_t buffin2[255];
int16_t  ay [800];
int16_t  ax [800];
TIM_HandleTypeDef htim4;
int posx=0;
int16_t  sampleBuffer[10];
int16_t  ringBuffer[810];
int sample = 0;
float logLevel;

uint8_t samples[1000];



/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/
static const void * _GetImageById(U32 Id, U32 * pSize) {
  switch (Id) {
  case ID_IMAGE_0_IMAGE_0:
    *pSize = sizeof(_acImage_0);
    return (const void *)_acImage_0;
  case ID_IMAGE_1_IMAGE_0:
    *pSize = sizeof(_acImage_1);
    return (const void *)_acImage_1;
  case ID_IMAGE_2_IMAGE_0:
    *pSize = sizeof(_acImage_2);
    return (const void *)_acImage_2;
  }
  return NULL;
}

// USER START (Optionally insert additional static code)
// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  const void * pData;
  WM_HWIN      hItem;
  U32          FileSize;
  int          NCode;
  int          Id;
  // USER START (Optionally insert additional variables)
  // USER END
  for (int i = 0; i<300; i++){
  	ax[i] = i;
  }
/*
  i++;
if(i==100 || i == 0){
	i=0;
	add = add * (-1);
}

level = level + add;


*/
/*
  hItem = WM_GetDialogItem(pMsg->hWin, ID_PROG_0);
  PROGBAR_SetValue(hItem, ((TS_State.touchX[0]-192)/4));
*/


/*
  BSP_TS_GetState(&TS_State);
     if(TS_State.touchDetected == TOUCH_EVENT_PRESS_DOWN)
	{
	  GUI_Clear();
	  GUI_SetFont(&GUI_FontComic24B_ASCII);
	  GUI_SetColor(GUI_BLACK);

	  x = TS_State.touchX[0];
	  y = TS_State.touchY[0];



	}

*/
  //GUI_Clear();
  //HAL_TIM_Base_Start(&htim4);
  //HAL_DAC_Start_DMA(&hdac, DAC_CHANNEL_1, (uint32_t*)buffin, 100, DAC_ALIGN_8B_R);
  //HAL_DAC_Start_DMA(&hdac, DAC_CHANNEL_2, (uint32_t*)buffin2, 100, DAC_ALIGN_8B_R);
/*
 //FIRST WORKING VERSION OF WAVEFORM
  	 posx=0;
     for(int i=0; i<80;i++){
    	 HAL_ADC_Start(&hadc1);
		 if(HAL_ADC_PollForConversion(&hadc1,1) == HAL_OK){

			 adc1 = HAL_ADC_GetValue(&hadc1)*(3400.0/4096);
			 ay [i] = adc1/5;

			 if (adc1 > 0 && adc1 <= 120){GUI_SetColor( 0xFF808080 );}
			 else if (adc1 > 150 && adc1 <=180){GUI_SetColor( 0xFF707070 );}
			 else if (adc1 > 180 ){GUI_SetColor( 0xFF606060 );}
			 adc1 = adc1 *2;
			lineStart = 240 - adc1/2;
			lineEnd = lineStart + adc1;

			for(int i = 0; i<10; i++){
				if(i<4){
					GUI_DrawVLine(posx+i,lineStart-i, lineEnd+i);
				}
				if(i==4){
					GUI_DrawVLine(posx+i,lineStart, lineEnd);
				}
				if(i>4){
					GUI_DrawVLine(posx+i,lineStart+i, lineEnd-i);
				}
			}


			 posx=posx+10;
		 }
		 avAdc1 = avAdc1 + adc1;
     }
     avAdc1 = avAdc1/100;
     */

     /*
     GUI_Clear();
     GUI_SetPenSize( 20 );
     GUI_SetColor( GUI_BLUE );
     GUI_DrawGraph(ay, GUI_COUNTOF(ay), 0, 0);
     */
/*

  if(sample == 9)
{
  for(int i=0; i<10;i++){
 	 HAL_ADC_Start(&hadc1);
		 if(HAL_ADC_PollForConversion(&hadc1,1) == HAL_OK){
			 adc1 = HAL_ADC_GetValue(&hadc1)*(3400.0/4096);
			 sampleBuffer [i] = adc1*2;
			 avAdc1 = avAdc1 + adc1;
		 }
  	  }
  avAdc1 = avAdc1/10;
     for(int i=0; i<810;i++){
    	 if (i>799){
    		 ringBuffer[i] = sampleBuffer[i-799];
    	 	 }
    	 else {
    		 ringBuffer[i] = ringBuffer[i+9];
    	 	 }

     	 }
     sample = 0;
}




	for(int i=0; i<800;i++){
        	 lineStart = 240 - ringBuffer[i+sample]/2;
        	 lineEnd = lineStart + ringBuffer[i+sample];
        	 GUI_DrawVLine(i,lineStart, lineEnd);
         	 }
	sample = sample +1;

*/

/*********************

  HAL_ADC_Start(&hadc1);
		 if(HAL_ADC_PollForConversion(&hadc1,1) == HAL_OK){
			 adc1 = HAL_ADC_GetValue(&hadc1)*(3400.0/4089);
		 }

		 level = adc1*2;
		 avAdc1 = adc1;
*/




for (int i = 0; i<1000;i++){
	samples[i] = (DMA_TRANSFER[i] & 0x000000ffUL);
	}


     for(int i=0; i<400;i++){
    		 ringBuffer[i] = ringBuffer[i+1];
     	 }

if (samples [0] >=150 && samples[0] <=160){
     	ringBuffer[400] = 0;
     }
else if (samples[0]<150){
	ringBuffer[400] = 160 - samples[0];
}

else if (samples [0] >160){
	ringBuffer[400] = samples[0]-160;
}


//ringBuffer[400] = samples[0];


	for(int i=0; i<400;i++){
        	 lineStart = 240 - (2*ringBuffer[i]/2);
        	 lineEnd = lineStart + (2*ringBuffer[i]);
        	 GUI_DrawVLine(i+200,lineStart, lineEnd);
         	 }




     HAL_ADC_Start(&hadc2);
     if(HAL_ADC_PollForConversion(&hadc2,1) == HAL_OK){
    	 adc2 = HAL_ADC_GetValue(&hadc2)*(3400.0/4096);
     }

	  GUI_SetFont(&GUI_FontD36x48);
	  GUI_SetColor(GUI_GRAY);
	  GUI_DispDecAt(avAdc1, 20, 15, 4);
	  GUI_DispDecAt(adc2, 20, 420, 4);

	  char *A[4];
	  char *B[4];

	  sprintf(A, "%d", adc1);
	  sprintf(B, "%d", adc2);

	  char str[11];

	  strcpy(str, "*");
	  if(adc1<10){strcat(str, "0");}
	  if(adc1<100){strcat(str, "0");}
	  if(adc1<1000){strcat(str, "0");}
	  strcat(str, A);
	  strcat(str, "-");
	  if(adc2<10){strcat(str, "0");}
	  if(adc2<100){strcat(str, "0");}
	  if(adc2<1000){strcat(str, "0");}
	  strcat(str, B);
	  strcat(str, "\r\n");

	  CDC_Transmit_FS(str, 11);


  switch (pMsg->MsgId) {

  case WM_PAINT:
	  GUI_SetBkColor(GUI_LIGHTGRAY);
	  GUI_Clear();
    break;



  case WM_INIT_DIALOG:
    //
    // Initialization of 'Image'
    //
    // Initialization of 'Text'
    //
/*
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
*/
	hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_0);
	TEXT_SetTextColor(hItem, GUI_GRAY);
    TEXT_SetText(hItem, "dB");
    TEXT_SetFont(hItem, GUI_FONT_32B_1);


	hItem = WM_GetDialogItem(pMsg->hWin, ID_TEXT_1);
	GUI_SetColor(GUI_GRAY);
	TEXT_SetTextColor(hItem, GUI_GRAY);
    TEXT_SetText(hItem, "dB");
    TEXT_SetFont(hItem, GUI_FONT_32B_1);


    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;

  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;

    switch(Id) {
	case ID_BUTTON_0: // Notifications sent by 'Button'
	  switch(NCode) {
	  case WM_NOTIFICATION_CLICKED:
		// USER START (Optionally insert code for reacting on notification message)
		  CDC_Transmit_FS("button_0 clicked\r\n", 18);
		  //for (int i=0; i<100;i++){buffin[i]=i*0;}
		  for (int i=0; i<255;i++){buffin2[i]=i*0;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
			BUTTON_SetPressed(hItem, 1);
			hItem = WM_GetDialogItem(pMsg->hWin, ID_PROG_0);
			i=i+1;
			PROGBAR_SetValue(hItem, Value);
		// USER END
		break;
	  case WM_NOTIFICATION_RELEASED:
		// USER START (Optionally insert code for reacting on notification message)
		// USER END
		break;
	  // USER START (Optionally insert additional code for further notification handling)
	  // USER END
	  }
	  break;
  case ID_BUTTON_1: // Notifications sent by 'Button'
	switch(NCode) {
	case WM_NOTIFICATION_CLICKED:
	  // USER START (Optionally insert code for reacting on notification message)
	  CDC_Transmit_FS("button_1 clicked\r\n", 18);
	  //for (int i=0; i<100;i++){buffin[i]=i*1;}
	  for (int i=0; i<255;i++){buffin2[i]=i*1;}
		hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
		BUTTON_SetPressed(hItem, 1);
	  // USER END
	  break;
	case WM_NOTIFICATION_RELEASED:
	  // USER START (Optionally insert code for reacting on notification message)
	  // USER END
	  break;
	// USER START (Optionally insert additional code for further notification handling)
	// USER END
	}
	break;

    case ID_BUTTON_2: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
    	  	CDC_Transmit_FS("button_2 clicked\r\n", 18);
    	  	//for (int i=0; i<100;i++){buffin[i]=i*2;}
    	  	for (int i=0; i<255;i++){buffin2[i]=i*2;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
			BUTTON_SetPressed(hItem, 1);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;

      case ID_BUTTON_3: // Notifications sent by 'Button'
        switch(NCode) {
        case WM_NOTIFICATION_CLICKED:
          // USER START (Optionally insert code for reacting on notification message)
      	  CDC_Transmit_FS("button_3 clicked\r\n", 18);
      	//for (int i=0; i<100;i++){buffin[i]=i*3;}
      	for (int i=0; i<255;i++){buffin2[i]=i*3;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
			BUTTON_SetPressed(hItem, 1);
          // USER END
          break;
        case WM_NOTIFICATION_RELEASED:
          // USER START (Optionally insert code for reacting on notification message)
          // USER END
          break;
        // USER START (Optionally insert additional code for further notification handling)
        // USER END
        }
        break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }





}
WM_MESSAGE mess;

void CDC_ReceiveCallBack(uint8_t *buf, uint32_t len){
Value = &buf;
BSP_LED_Toggle(LED1);
}


/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  WM_Paint(hWin);
  return hWin;
}

// USER START (Optionally insert additional public code)
// USER END

/*************************** End of file ****************************/
