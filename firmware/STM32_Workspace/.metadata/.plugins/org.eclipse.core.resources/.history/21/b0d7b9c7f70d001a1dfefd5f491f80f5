#include "lwip.h"
#include "UDP_SEND_RECIVE.h"

static struct udp_pcb *udpPcb;

	  //==================================SENDING UDP MESSAGE===================================//

	  void SendUDP(char *UDP_Message, int size ){

		ip_addr_t       client1IpAddr; //The Clients IP Adress
		struct pbuf     *ethTxBuffer_p;

	    IP4_ADDR(&client1IpAddr, 192, 168, 1, 36); //IP Adress to send UDP to in this CASE BROADCAST!!!

	    char UDP[size];
	    for (int i=0;i<size;i++){
	    	UDP[i] = UDP_Message[i];
	    }


	    ethTxBuffer_p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM); //TX BUFFER TO SOMETHING WE CAN SEND
	    if (ethTxBuffer_p == NULL){}

	    memcpy(ethTxBuffer_p->payload, UDP, size);

	    udp_sendto(udpPcb, ethTxBuffer_p, &client1IpAddr,9002);  //SEND UDP TO PORT 9002

	    pbuf_free(ethTxBuffer_p);  //Free the TX Buffer
	  }


	 //==================================Recive UDP MESSAGE===================================//

	  void udp_recive(void *arg, struct udp_pcb *pcb, struct pbuf *p, const ip_addr_t *addr, u16_t port)
	  {
		HAL_GPIO_TogglePin(GPIOB, LD2_Pin); //Blaue LED an
		memcpy(str, p -> payload, p -> len);
	    pbuf_free(p);

	  }
	 //=======================================================================================//

	 //==================================INIT UDP Session===================================//
	    void UDP_init(void){
	      err_t         udpErr;
	      ip_addr_t     ownIPaddr;
	      udpPcb = udp_new();

	      if(udpPcb != NULL)
	      {
	        IP4_ADDR(&ownIPaddr, 192, 168, 1, 205); //The IP Adress of the STM32
	        udpErr = udp_bind(udpPcb, &ownIPaddr, 9001); //Definition of
	        udp_recv(udpPcb, udp_recive, NULL);
	        if (udpErr ==ERR_OK){
	        }
	      }
	      udp_recv(udpPcb, udp_recive, NULL);//Create udp_recive callback
	    }
	  //=======================================================================================//







void OSCmessageINTSend(char *OSCAdress,int size, int value){

	    	 int index=0;
	    	 char UDP_Message[100];

	    	 for(int i=0; i< 100; i++){
	    		 UDP_Message[i] = 0x01;
	    	 }


	    	 for(int i=0; i< size; i++){
		    	 UDP_Message[i] = OSCAdress[i];
	    	 }

	    	 if(size==35||size==31||size==27||size==23||size == 19||size == 15||size == 11||size == 7||size == 3){
	    		 UDP_Message[size] = 0x00;
	    		 index=1;
	    	 }
	    	 else if(size==34||size==30||size==26||size==22||size == 18||size == 16||size == 12||size == 8||size == 4){

	    		 UDP_Message[size] = 0x00;
	    		 UDP_Message[size+1] = 0x00;
	    		 index=2;
	    	 }
	    	 else if(size==33||size==29||size==25||size==21||size == 17||size == 15||size == 11||size == 7||size == 3){
	    		 UDP_Message[size] = 0x00;
	    		 UDP_Message[size+1] = 0x00;
	    		 UDP_Message[size+2] = 0x00;
	    		 index=3;
	    	 }
	    	 else if(size==32||size==28||size==24||size==20||size == 16||size == 14||size == 10||size == 6||size == 2){
	    		 UDP_Message[size] = 0x00;
	    		 UDP_Message[size+1] = 0x00;
	    		 UDP_Message[size+2] = 0x00;
	    		 UDP_Message[size+3] = 0x00;
	    		 index=4;
	    	 }

    		 UDP_Message[size+index] = ',';
    		 UDP_Message[size+index+1] = 'i';
    		 UDP_Message[size+index+2] = 0x00;
    		 UDP_Message[size+index+3] = 0x00;
    		 UDP_Message[size+index+4] = 0x00;
    		 UDP_Message[size+index+5] = 0x00;
    		 UDP_Message[size+index+6] = 0x00;
    		 UDP_Message[size+index+7] = value;

    		 char UDP_SEND[size+index+8];

	    	 for(int i=0; i< size+index+8; i++){
	    		 UDP_SEND[i] = UDP_Message[i];
	    	 }

    		 SendUDP(UDP_SEND, sizeof(UDP_SEND));
	     }
