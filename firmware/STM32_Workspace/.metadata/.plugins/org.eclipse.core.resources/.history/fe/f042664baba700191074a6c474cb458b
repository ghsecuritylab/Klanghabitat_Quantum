/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
#include "GUI_App.h"
#include "DIALOG.h"
#include "usb_device.h"
#include "math.h"
#include "main.h"
#include "settings.h""
//#include "stm32f4xx_hal.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

char Value;
#define ID_WINDOW_0  (GUI_ID_USER + 0x00)
#define ID_BUTTON_0  (GUI_ID_USER + 0x04)
#define ID_BUTTON_1  (GUI_ID_USER + 0x05)
#define ID_BUTTON_2  (GUI_ID_USER + 0x06)
#define ID_BUTTON_3  (GUI_ID_USER + 0x07)
#define ID_TEXT_0  (GUI_ID_USER + 0x08)
#define ID_PROG_0  (GUI_ID_USER + 0x09)
#define ID_SLID_0  (GUI_ID_USER + 0x10)
#define ID_TEXT_1  (GUI_ID_USER + 0x11)
#define ID_IMAGE_0_IMAGE_0  0x00
#define ID_IMAGE_1_IMAGE_0  0x01
#define ID_IMAGE_2_IMAGE_0  0x02

// USER START (Optionally insert additional defines)
// USER END

static void drawFloat (int pos_x, int pos_y, float val, const char * s);
static const GUI_WIDGET_CREATE_INFO _aDialogCreate[] = {
  { WINDOW_CreateIndirect, "Window", ID_WINDOW_0, 0, 0, 800, 480, 0, 0x0, 0 },


  // USER START (Optionally insert additional widgets)
  // USER END
};


uint8_t i=0;
int add=1;
int adress[255];
int level = 0;
TS_StateTypeDef TS_State;
ADC_HandleTypeDef hadc1;
ADC_HandleTypeDef hadc2;
I2C_HandleTypeDef hi2c2;


DAC_HandleTypeDef hdac;
uint32_t adc1, adc2,avAdc1,lineStart,lineEnd,adc2Last;
uint32_t DMA_buffin[20];
uint32_t DMA_buffer[21];
uint32_t avCH1;
uint32_t maxCH1;


uint8_t buffin[255],x;
uint32_t y = 240;
uint8_t buffin2[255];
int16_t  ay [800];
int16_t  ax [800];
TIM_HandleTypeDef htim4;
int posx=0;
int16_t  sampleBuffer[10];
int16_t  ringBuffer[810];
int sample = 0;
float logLevel;
int startup = 0;
uint16_t samples[250];
uint16_t samples2[250];
int Attack_X =0;
int Attack_Y =0;

uint8_t i2cWrite[4];
uint8_t i2cRead[5];
uint8_t i2cBuf[16];
//uint16_t knob1 = 146;
TS_StateTypeDef TS_State;

int ok = 0;
uint32_t t = 0;
uint32_t q = 0;
uint8_t i2cBuffer[2];
uint8_t i2cBuffer2[2];
/*
uint16_t knob1 = 146;
uint16_t knob2 = 147;
*/
uint16_t knob1 = 64;
uint16_t knob2 = 32;


int X = 0;
int Y = 0;
int POS_Y=0;

int poti1 = 0;
int poti2 = 0;

int delay1 = 0;
int delay2 = 0;
/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/


// USER START (Optionally insert additional static code)






// USER END

/*********************************************************************
*
*       _cbDialog
*/
static void _cbDialog(WM_MESSAGE * pMsg) {
  const void * pData;
  WM_HWIN      hItem;
  U32          FileSize;
  int          NCode;
  int          Id;
  // USER START (Optionally insert additional variables)
  // USER END
  for (int i = 0; i<300; i++){
  	ax[i] = i;
  }


for (int i = 0, p=0; i<250;i++){

	samples2[p] =   (DMA_TRANSFER[i] & 0xff000000UL)>>24;
	samples2[p+1] = (DMA_TRANSFER[i] & 0x00ff0000UL)>>16;
	samples2[p+2] = (DMA_TRANSFER[i] & 0x0000ff00UL)>>8;
	samples2[p+3] = (DMA_TRANSFER[i] & 0x000000ffUL);
	p=p+3;
	}

for (int i = 0; i<63;i++){
	samples[i] = (DMA_TRANSFER[i] & 0x000000ffUL);
	}



for (int i = 0; i < 250; i++ ){
	  avCH1 = samples[i]+avCH1;
}
avCH1= avCH1 / 63;


for (int i = 0; i < 63; i++)
 {
   if (samples[i] > maxCH1)
   {
	   maxCH1  = samples[i];
   }
 }


 for(int i=0; i<300;i++){
    ringBuffer[i] = ringBuffer[i+1];
    }


 if (maxCH1<=127){
	 ringBuffer[300] = 127-maxCH1;
 }

 else if (maxCH1 >127){
	 ringBuffer[300] = maxCH1-127;
 }
maxCH1 = 0;

	for(int i=0; i<300;i++){
        	 lineStart = 240 - (4*ringBuffer[i]/2);
        	 lineEnd = lineStart + (4*ringBuffer[i]);
        	 GUI_SetColor( GUI_ORANGE );
        	 GUI_DrawVLine(i+250,lineStart, lineEnd);
         	 }

     HAL_ADC_Start(&hadc2);
     if(HAL_ADC_PollForConversion(&hadc2,1) == HAL_OK){
    	 adc2 = HAL_ADC_GetValue(&hadc2)*100/180;
     }



    	 i2cBuffer[0]= 0x0B;
    	 HAL_I2C_Master_Transmit(&hi2c2, knob1,i2cBuffer,1,100);
    	 HAL_I2C_Master_Receive(&hi2c2, knob1, &i2cBuffer[1],1,100);


    	 if(poti1!=i2cBuffer[1]){
    		delay1 = 50;
    	 }

    	 if (delay1>0){
    		 delay1 --;
    		 GUI_SetColor(GUI_ORANGE);
    	 }
    	 else {
        	 GUI_SetColor(GUI_LIGHTGRAY);
    	 }
    	 poti1 = i2cBuffer[1];
    	 GUI_SetFont(&GUI_FontD36x48);
    	 drawFloat(20,400,poti1, "ms");






    	 i2cBuffer2[0]= 0x0B;
		 HAL_I2C_Master_Transmit(&hi2c2, knob2,i2cBuffer2,1,100);
		 HAL_I2C_Master_Receive(&hi2c2, knob2, &i2cBuffer2[1],1,100);

    	 if(poti2!=i2cBuffer2[1]){
    		delay2 = 50;
    	 }

    	 if (delay2>0){
    		 delay2 --;
    		 GUI_SetColor(GUI_ORANGE);
    	 }
    	 else {
        	 GUI_SetColor(GUI_LIGHTGRAY);
    	 }

		 poti2 = i2cBuffer2[1];
		 GUI_SetFont(&GUI_FontD36x48);
		 drawFloat(560,400,poti2, "dB");



     logLevel = adc2/5.0;
/*
	  GUI_SetFont(&GUI_FontD36x48);
	  GUI_SetColor(GUI_GRAY);
	  GUI_DispDecAt(avCH1, 20, 35, 4);
*/

	  /*==============Display Numbers================*/

	  GUI_SetColor(GUI_GRAY);

	  GUI_SetFont(&GUI_FontD36x48);
      drawFloat(20,35,ringBuffer[300]/10.0, "dBU");

      GUI_SetFont(&GUI_FontD36x48);
      drawFloat(560,35,ringBuffer[100]/10.0, "dBU");

      GUI_SetFont(&GUI_FontD24x32);
      drawFloat(320,35,X, "");

      GUI_SetFont(&GUI_FontD24x32);
      drawFloat(320,80,Y, "");



      GUI_DrawBitmap(&bmsettings, 350, 370);


	  GUI_SetFont(&GUI_FontD36x48);
	  GUI_SetColor(GUI_WHITE);
	  drawFloat(20,220,adc2/12.0, "dB");

	  GUI_SetFont(&GUI_FontD24x32);
	  GUI_SetColor( GUI_WHITE );
	  drawFloat(560,125+adc2,adc2/12.0, "");
	  /*===============================================*/


	  if (avCH1<=127){
	  	level = 127-avCH1;
	  }

	  else if (avCH1 >127){
	  	level = avCH1-127;
	  }




	  GUI_SetColor( GUI_WHITE );

	  GUI_DrawHLine(140+adc2,250, 550);
	  GUI_DrawHLine(139+adc2,250, 550);
	  GUI_DrawHLine(138+adc2,250, 550);

	  GUI_DrawHLine(340-adc2,250, 550);
	  GUI_DrawHLine(341-adc2,250, 550);
	  GUI_DrawHLine(342-adc2,250, 550);





	  GUI_SetColor( GUI_WHITE );

     for (int i=120; i <360;){
    	 GUI_DrawHLine(i,700, 750);
     i=i+10;
     }

	  GUI_SetColor( GUI_ORANGE );

	  if(POS_Y != Y){
		  if(POS_Y>Y){
			  POS_Y = POS_Y-5;
		  }
		  if(POS_Y<Y){
			  POS_Y = POS_Y+5;
		  }
	  }

	  if(X>700){
		  GUI_DrawHLine(POS_Y,700, 750);
		  GUI_DrawHLine(POS_Y+1,700, 750);
		  GUI_DrawHLine(POS_Y+2,700, 750);
		  GUI_DrawHLine(POS_Y+3,700, 750);
		  GUI_DrawHLine(POS_Y+4,700, 750);
		  GUI_DrawHLine(POS_Y+5,700, 750);

	  }

	  adc2Last = adc2;





	  char *A[4];
	  char *B[4];

	  sprintf(A, "%d", adc1);
	  sprintf(B, "%d", adc2);

	  char str[11];

	  strcpy(str, "*");
	  if(adc1<10){strcat(str, "0");}
	  if(adc1<100){strcat(str, "0");}
	  if(adc1<1000){strcat(str, "0");}
	  strcat(str, A);
	  strcat(str, "-");
	  if(adc2<10){strcat(str, "0");}
	  if(adc2<100){strcat(str, "0");}
	  if(adc2<1000){strcat(str, "0");}
	  strcat(str, B);
	  strcat(str, "\r\n");

	  CDC_Transmit_FS(str, 11);








  switch (pMsg->MsgId) {

  case WM_PAINT:
	  GUI_SetBkColor(GUI_DARKGRAY);
	  GUI_Clear();
    break;






  case WM_INIT_DIALOG:
    //
    // Initialization of 'Image'
    //
    // Initialization of 'Text'
    //
/*
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
	hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
	BUTTON_SetFont(hItem, GUI_FONT_32B_1);
*/




    // USER START (Optionally insert additional code for further widget initialization)
    // USER END
    break;

  case WM_NOTIFY_PARENT:
    Id    = WM_GetId(pMsg->hWinSrc);
    NCode = pMsg->Data.v;

    switch(Id) {
	case ID_BUTTON_0: // Notifications sent by 'Button'
	  switch(NCode) {
	  case WM_NOTIFICATION_CLICKED:
		// USER START (Optionally insert code for reacting on notification message)
		  CDC_Transmit_FS("button_0 clicked\r\n", 18);
		  //for (int i=0; i<100;i++){buffin[i]=i*0;}
		  for (int i=0; i<255;i++){buffin2[i]=i*0;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_0);
			BUTTON_SetPressed(hItem, 1);
			hItem = WM_GetDialogItem(pMsg->hWin, ID_PROG_0);
			i=i+1;
			PROGBAR_SetValue(hItem, Value);
		// USER END
		break;
	  case WM_NOTIFICATION_RELEASED:
		// USER START (Optionally insert code for reacting on notification message)
		// USER END
		break;
	  // USER START (Optionally insert additional code for further notification handling)
	  // USER END
	  }
	  break;
  case ID_BUTTON_1: // Notifications sent by 'Button'
	switch(NCode) {
	case WM_NOTIFICATION_CLICKED:
	  // USER START (Optionally insert code for reacting on notification message)
	  CDC_Transmit_FS("button_1 clicked\r\n", 18);
	  //for (int i=0; i<100;i++){buffin[i]=i*1;}
	  for (int i=0; i<255;i++){buffin2[i]=i*1;}
		hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_1);
		BUTTON_SetPressed(hItem, 1);
	  // USER END
	  break;
	case WM_NOTIFICATION_RELEASED:
	  // USER START (Optionally insert code for reacting on notification message)
	  // USER END
	  break;
	// USER START (Optionally insert additional code for further notification handling)
	// USER END
	}
	break;

    case ID_BUTTON_2: // Notifications sent by 'Button'
      switch(NCode) {
      case WM_NOTIFICATION_CLICKED:
        // USER START (Optionally insert code for reacting on notification message)
    	  	CDC_Transmit_FS("button_2 clicked\r\n", 18);
    	  	//for (int i=0; i<100;i++){buffin[i]=i*2;}
    	  	for (int i=0; i<255;i++){buffin2[i]=i*2;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_2);
			BUTTON_SetPressed(hItem, 1);
        // USER END
        break;
      case WM_NOTIFICATION_RELEASED:
        // USER START (Optionally insert code for reacting on notification message)
        // USER END
        break;
      // USER START (Optionally insert additional code for further notification handling)
      // USER END
      }
      break;

      case ID_BUTTON_3: // Notifications sent by 'Button'
        switch(NCode) {
        case WM_NOTIFICATION_CLICKED:
          // USER START (Optionally insert code for reacting on notification message)
      	  CDC_Transmit_FS("button_3 clicked\r\n", 18);
      	//for (int i=0; i<100;i++){buffin[i]=i*3;}
      	for (int i=0; i<255;i++){buffin2[i]=i*3;}
			hItem = WM_GetDialogItem(pMsg->hWin, ID_BUTTON_3);
			BUTTON_SetPressed(hItem, 1);
          // USER END
          break;
        case WM_NOTIFICATION_RELEASED:
          // USER START (Optionally insert code for reacting on notification message)
          // USER END
          break;
        // USER START (Optionally insert additional code for further notification handling)
        // USER END
        }
        break;
    // USER START (Optionally insert additional code for further Ids)
    // USER END
    }
    break;
  // USER START (Optionally insert additional message handling)
  // USER END
  default:
    WM_DefaultProc(pMsg);
    break;
  }





}
WM_MESSAGE mess;

void CDC_ReceiveCallBack(uint8_t *buf, uint32_t len){
Value = &buf;
BSP_LED_Toggle(LED1);
}

void drawFloat (int pos_x, int pos_y, float val, const char * s){

			  GUI_GotoXY(pos_x, pos_y);
	  		  GUI_DispFloatMin(val, 2);


	  		  GUI_SetFont(&GUI_Font32B_1);
	  		  if(val < 10.0 && val >= 0) {GUI_DispStringAt(s, 150+pos_x, 20+pos_y);}
	  		  else if (val > 10.0 || val<0){GUI_DispStringAt(s, 185+pos_x, 20+pos_y);}


	  	  }

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/
WM_HWIN CreateWindow(void);
WM_HWIN CreateWindow(void) {
  WM_HWIN hWin;

  hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  WM_Paint(hWin);
  return hWin;
}

// USER START (Optionally insert additional public code)


// USER END

/*************************** End of file ****************************/
