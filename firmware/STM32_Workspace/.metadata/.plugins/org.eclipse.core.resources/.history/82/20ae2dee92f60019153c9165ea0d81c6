/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
#include "GUI_App.h"
#include "DIALOG.h"
#include "usb_device.h"
#include "math.h"
#include "main.h"
#include "settings.h"
#include "GUI.h"
//#include "stm32f4xx_hal.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/

char Value;
#define ID_WINDOW_0  (GUI_ID_USER + 0x00)

uint8_t byte;

//UART_HandleTypeDef huart6;
// USER START (Optionally insert additional defines)
// USER END

static void drawFloat (int pos_x, int pos_y, float val, const char * s,const char * h);
void drawBar (int pos_x, int pos_y, float PeakVal,float AvVal, const char * s );
void drawVBar (int pos_x, int pos_y, float PeakVal,float AvVal, const char * s );
void drawWaveForm();
void drawWaveFormUart(int x,int y, int adc);
void drawWaveFormUart2(int x,int y, int adc);



uint32_t lineStart,lineEnd;
uint32_t avCH1;
uint32_t maxCH1;
int16_t  ringBuffer[810];
int16_t  ringBufferSim[810];
uint16_t samples[250];
int p = 0;


//Interface Variablen
int X = 400; //TOUCH X
int Y = 0; //TOUCH Y

int adc1 = 0;
float adc1_ist = 0;
float adc1_volt = 0;
float adc1_db = 0;
float adc1_db_negative = 0;



int adc2 = 0;
int watchdog= 0;
int left = 0;
int right = 0;
int pots[6];
int poti[6];
int delay[6];
int pox[6]={15,15,15,620,620,620};
int poy[6]={220,400,70,400,70,220};
const char *header[6] = {"Input","Threshold","Attack","Ratio","Release","Output"};
const char *units[6] = {"dB","dB","ms","","ms","dB"};
char str[12];

begin = 0;
int refresh =0;
float smooth= 0;
float peaksmooth= 0;
int once = 0;



int levelIN1 = 0;
int levelIN2 = 0;
/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/


// USER START (Optionally insert additional static code)


// USER END

/*********************************************************************
*
*       _cbDialog
*///

static void _cbDialog(WM_MESSAGE * pMsg) {

  // USER START (Optionally insert additional variables)
	/***************** Sort Incoming data ********************/
	 int start = 0;
	    	     int offset = 0;
	    	     char incommingData[10];
	    	     for(int i = 0; i<10;i++){
	    	    	 if (UART_RECIVE[i] == 0xFF){
	    	    		   start = i; //found start index @start
	    	    		   break;
	    	    	 }
	    	     }

	    	     if (start == 0){
	    	    	 for (int i = 0; i< 10;i++){
	    	    	      incommingData[i] = UART_RECIVE[i];
	    	    	 }
	    	     }
	    	     else if (start != 0){
	        	     for (int i = 0; i< 10;i++){
	        	    	 incommingData[i] = UART_RECIVE[i+start];
	        	    	 offset = i+1;
	        	    	 if (i+start == 9){
	        	    		 break;
	        	    	 }
	        	     }
	        	     for (int i = 0; i< 10;i++){
	        	    	 incommingData[i+offset] = UART_RECIVE[i];
	        	    	 if (i+offset == 9){
	        	    		 break;
	        	    	 }
	        	     }
	    	     }
	   /**********************************************************/



	    	     watchdog = incommingData[1];
	    	     adc1 = incommingData[3];
	    	     levelIN2 = incommingData[4];




  // USER END
if (once == 0){
	GUI_SetBkColor(GUI_DARKGRAY);
	GUI_Clear();
	once = 1;
}

  switch (pMsg->MsgId) {
  case WM_PAINT:
	  //GUI_SetBkColor(GUI_DARKGRAY);
	  //GUI_Clear();

		HAL_GPIO_TogglePin(GPIOA, LAMP1_Pin);
	    	HAL_GPIO_TogglePin(GPIOG, LAMP2_Pin);
    break;

  default:
    WM_DefaultProc(pMsg);

  }


  //GUI_DrawBitmap(&bmsettings, 400, 50);
  if (refresh >=0){
	  GUI_SetBkColor(GUI_DARKGRAY);
	  //GUI_ClearRect(600,0,800,480);
	  //GUI_ClearRect(0,0,200,480);
	  //GUI_ClearRect(200,300,600,480);
	  GUI_DCACHE_Clear(0);

	  GUI_Clear();
  	refresh = 0;
  }
refresh++;

  for (int i = 0; i<810; i++){
 	 ringBufferSim[i] = p;
 	 p++;
 	 if (p>=60){
 		 p=0;
 	 }
  }

     drawWaveFormUart(0,240,adc1);
     drawWaveFormUart2(450,240,adc1);

     adc1_ist = adc1;
	 adc1_volt = (adc1/255.00)*3.6;
	 adc1_db = 10*log(adc1_volt/3.0);
	 if (adc1_db<=-300.0) {adc1_db = -300;}

	 adc1_db = adc1_db;

	 if(adc1_db-smooth<0){
		 smooth = smooth+(0.05*(adc1_db-smooth));
	 }
	 else {
		 smooth = smooth+(0.05*(adc1_db-smooth));
	 }

	 if(adc1_db-peaksmooth<0){
		 peaksmooth = peaksmooth+(0.01*(adc1_db-peaksmooth));
	 }
	 else {
		 peaksmooth = peaksmooth+(1*(adc1_db-peaksmooth));
	 }


	 drawBar (390, 90,300+peaksmooth,300+smooth, "");
	 drawBar (440, 90,300+peaksmooth,300+smooth, "");


/*
	 drawBar (400, 100,300+peaksmooth,300+smooth, "");

	 drawBar (450, 100,300+peaksmooth,300+smooth, "");
	 drawBar (500, 100,300+peaksmooth,300+smooth, "");
*/


/*****************DIPLAY ENCODER VALUES**************/
  for(int i = 1; i<5; i++){
	 if(poti[i]!=pots[i]){
		delay[i] = 50;
	 }
	 if (delay[i]>0){
		 delay[i] --;
		 GUI_SetColor(GUI_ORANGE);
	 }
	 else {GUI_SetColor(GUI_LIGHTGRAY);}
	 poti[i] = pots[i];
	 GUI_SetFont(&GUI_FontD24x32);
	 drawFloat(pox[i],poy[i],poti[i], units[i],header[i]);
	 drawVBar (pox[i], poy[i]+45,0,poti[i], "");
}

/*==================================================*/

GUI_SetFont(&GUI_Font24B_1);

GUI_SetColor(GUI_GRAY);

}



void drawWaveFormUart(int x,int y, int adc){

	 for(int i=0; i<350;i++){
	    ringBuffer[i] = ringBuffer[i+1];
	    }

	GUI_SetColor( GUI_ORANGE );



		for(int i=0; i<350;i++){


		    ringBuffer[350] = adc;
	        lineStart = y - (ringBuffer[i]/2);
	        lineEnd = lineStart + (ringBuffer[i]);

	        GUI_DrawVLine(x+i,lineStart, lineEnd);

	     }


	/****************************************************/
}

void drawWaveFormUart2(int x,int y, int adc){

	 for(int i=0; i<350;i++){
	    ringBuffer[i] = ringBuffer[i+1];
	    }

	GUI_SetColor( GUI_ORANGE );



		for(int i=0; i<350;i++){


		    ringBuffer[350] = adc;
	        lineStart = y - (ringBuffer[i]/2);
	        lineEnd = lineStart + (ringBuffer[i]);

	        GUI_DrawVLine(350+x-i,lineStart, lineEnd);
	     }


	/****************************************************/
}

void drawVBar (int pos_x, int pos_y, float PeakVal,float AvVal,  const char * s ){

	int lastLine = 0;
	int bottomX = 0;

	GUI_SetColor(GUI_LIGHTGRAY);
	for (int i=0; i<15; i++){
			lastLine = pos_x+(i*10);
			//GUI_DrawVLine(lastLine+0,pos_y, pos_y+10);
			//GUI_DrawVLine(lastLine+5,pos_y, pos_y+5);
		}
		//GUI_DrawVLine(lastLine+10,pos_y, pos_y+10);
		bottomX = lastLine+10;

		GUI_DrawGradientV(pos_x, pos_y-10, pos_x+AvVal, pos_y, 0xFFFF8000, 0xFFFFA500);

}

void drawBar (int pos_x, int pos_y, float PeakVal,float AvVal,  const char * s ){
	/*DRAW RASTER*/
	int lastLine = 0;
	int bottomY = 0;
	int rednes = 0;


	GUI_SetColor(GUI_LIGHTGRAY);
	GUI_SetFont(&GUI_Font20_1);
	GUI_GotoXY(pos_x-40, pos_y-25);

    //GUI_DispFloatMin((AvVal-200)/4, 2);


	for (int i=0; i<30; i++){
		lastLine = pos_y+(i*10);
		//GUI_DrawHLine(lastLine+0,pos_x, pos_x+10);
		//GUI_DrawHLine(lastLine+5,pos_x, pos_x+5);
	}
	//GUI_DrawHLine(lastLine+10,pos_x, pos_x+10);
	bottomY = lastLine+10;

	rednes = AvVal *100 /bottomY;

	/*DRAW INDICATOR AV*/

	GUI_DrawGradientV(pos_x-30, pos_y, pos_x-1, bottomY- AvVal -1, 0xFF505050, 0xFF505050);
	GUI_DrawGradientV(pos_x-30, bottomY- AvVal, pos_x-1, bottomY, 0xFFFF6E00, 0xFFFFA500);


	if (PeakVal >298){PeakVal=298;}

	/*DRAW INDICATOR PEAK*/
	GUI_SetColor(GUI_RED);

	GUI_DrawHLine(bottomY-PeakVal-4,pos_x-30, pos_x-1);
	GUI_DrawHLine(bottomY-PeakVal-3,pos_x-30, pos_x-1);
	GUI_DrawHLine(bottomY-PeakVal-2,pos_x-30, pos_x-1);
	GUI_DrawHLine(bottomY-PeakVal-1,pos_x-30, pos_x-1);
	GUI_DrawHLine(bottomY-PeakVal,pos_x-30, pos_x-1);

}

void drawFloat (int pos_x, int pos_y, float val, const char * s, const char * h){
			  GUI_GotoXY(pos_x, pos_y);
	  		  GUI_DispFloatMin(val, 1);

			  GUI_SetFont(&GUI_Font24B_1);
	  		  if(val < 10.0 && val >= 0) {GUI_DispStringAt(s, 80+pos_x, 10+pos_y);}
	  		  else if (val >= 10.0 || val<0){GUI_DispStringAt(s, 105+pos_x, 10+pos_y);}
	  		  GUI_SetFont(&GUI_Font32B_1);
	  		  GUI_DispStringAt(h, pos_x, pos_y-35);

	  	  }

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/



WM_HWIN CreateWindow(void) {
  //WM_HWIN hWin;
  WM_HWIN hParent;

 // hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  //hParent = WM_CreateWindow(0, 0, 1, 1, WM_CF_SHOW, _cbDialog, 0); //THIS IS WORKING QUITE OK!!!
  hParent = WM_CreateWindow(200, 0, 1, 1,WM_CF_SHOW, _cbDialog, 0);
 // WM_Paint(hWin);

  WM_MULTIBUF_Enable(1);

  //return hWin;
  return hParent;
}

// USER START (Optionally insert additional public code)


// USER END

/*************************** End of file ****************************/
