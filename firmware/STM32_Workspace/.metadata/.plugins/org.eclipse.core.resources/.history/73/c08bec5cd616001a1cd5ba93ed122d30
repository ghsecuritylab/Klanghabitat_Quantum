/*********************************************************************
*                                                                    *
*                SEGGER Microcontroller GmbH & Co. KG                *
*        Solutions for real time microcontroller applications        *
*                                                                    *
**********************************************************************
*                                                                    *
* C-file generated by:                                               *
*                                                                    *
*        GUI_Builder for emWin version 5.40                          *
*        Compiled Jun 22 2017, 10:13:26                              *
*        (c) 2017 Segger Microcontroller GmbH & Co. KG               *
*                                                                    *
**********************************************************************
*                                                                    *
*        Internet: www.segger.com  Support: support@segger.com       *
*                                                                    *
**********************************************************************
*/

// USER START (Optionally insert additional includes)
// USER END
#include "GUI_App.h"
#include "DIALOG.h"
#include "usb_device.h"
#include "math.h"
#include "main.h"
#include "settings.h"
#include "GUI.h"
#include "stm32f4xx_hal.h"
#include "GuiElements/AudioMeter.h"
#include "GuiElements/Controlls.h"
#include "UART_IO.h"
/*********************************************************************
*
*       Defines
*
**********************************************************************
*/
I2C_HandleTypeDef hi2c1;
char Value;
#define ID_WINDOW_0  (GUI_ID_USER + 0x00)

uint8_t byte;
DMA_HandleTypeDef hdma_usart6_rx;
UART_HandleTypeDef huart6;
//UART_HandleTypeDef huart6;
// USER START (Optionally insert additional defines)
// USER END



TS_StateTypeDef TS_State;

uint32_t avCH1;
uint32_t maxCH1;

int16_t  ringBufferSim[810];
uint16_t samples[250];
int p = 0;


//Interface Variablen
int X = 0; //TOUCH X
int Y = 0; //TOUCH Y

int adc1 = 0;
float adc1_ist = 0;
float adc1_volt = 0;
float adc1_db = 0;
float smooth1= 0;
float peaksmooth1= 0;
float diff1 = 0;


int adc2 = 0;
float adc2_ist = 0;
float adc2_volt = 0;
float adc2_db = 0;
float smooth2= 0;
float peaksmooth2= 0;
float diff2 = 0;


int watchdog= 0;
int left = 0;
int right = 0;
int pots[6];



char str[12];

begin = 0;
int refresh =0;

int once = 0;
int Y_Right = 0;
int Y_Left = 0;

int levelIN1 = 0;
int levelIN2 = 0;
uint8_t buffer[10];


int maxValueLeft = 0;
int newValueLeft = 0;
int maxValueRight = 0;
int newValueRight = 0;
int reset = 0;


uint8_t payload = 0;
uint8_t Recive = 0;

uint8_t aTxBuffer[] = "DISPLAY123";

/* Buffer used for reception */
uint8_t aRxBuffer[10];

uint32_t CODE;
/*********************************************************************
*
*       Static code
*
**********************************************************************
*/
/*********************************************************************
*
*       _GetImageById
*/


// USER START (Optionally insert additional static code)


// USER END

/*********************************************************************
*
*       _cbDialog
*///

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart){

	BSP_LED_Toggle(LED1);
   	UARTRECIVER(); //Recive Data from UART --> UARTDATA

	newValueLeft = UARTDATA[3];
	newValueRight = UARTDATA[4];

	if(maxValueLeft < newValueLeft){
		maxValueLeft = newValueLeft;
	}

	if(maxValueRight < newValueRight){
		maxValueRight = newValueRight;
	}

	if(reset == 1){
		if(maxValueLeft==0){
		adc1 = 1;
		}
		else{
		adc1 = maxValueLeft;
		}
		if(maxValueRight==0){
		adc2 = 1;
		}
		else{
		adc2 = maxValueRight;
		}
		maxValueLeft = 0;
		maxValueRight = 0;
		reset = 0;
	}
}



static void _cbDialog(WM_MESSAGE * pMsg) {


  // USER END


  switch (pMsg->MsgId) {
  case WM_PAINT:
	  reset = 1;
	  HAL_GPIO_TogglePin(GPIOA, LAMP1_Pin);
    break;

  default:
	    reset = 1;
    WM_DefaultProc(pMsg);

  }


    HAL_GPIO_TogglePin(GPIOG, LAMP2_Pin);
	  GUI_SetBkColor(GUI_DARKGRAY);
	  GUI_DCACHE_Clear(0);
	  GUI_Clear();


     drawWaveFormUartRight(0,240,adc1);
     drawWaveFormUartLeft(450,240,adc2);


     adc1_ist = adc1;
     adc1_volt = (adc1/255.00)*3.3;
     adc1_db = 20*log(adc1_volt/0.775);



     adc2_ist = adc2;
	 adc2_volt = (adc2/255.00)*3.3;
	 adc2_db = 20*log(adc2_volt/0.775);



		GUI_GotoXY(350, 30);
		GUI_SetColor(GUI_LIGHTGRAY);
		GUI_SetFont(&GUI_Font24B_1);
	  	GUI_DispFloatMin(adc1_db, 1);

	  	GUI_GotoXY(450, 30);
	  	GUI_DispFloatMin(adc1_db+60, 1);


	 adc1_db = (adc1_db+60)*3;
	 adc2_db = (adc2_db+60)*3;


	 diff1 = adc1_db-smooth1;
	 diff2 = adc2_db-smooth2;

	 if(diff1<0){
		 smooth1 = smooth1+(0.055*diff1);
	 }
	 else{
		 smooth1 = smooth1+(1*diff1);
	 }

	 if((adc1_db-peaksmooth1)<0){
		 peaksmooth1 = peaksmooth1+(0.01*diff1);
	 }
	 else {
		 peaksmooth1= peaksmooth1+(1*diff1);
	 }


	 if(diff2<0){
		 smooth2 = smooth2+(0.055*diff2);
	 }
	 else{
		 smooth2 = smooth2+(1*diff2);
	 }

	 if((adc2_db-peaksmooth2)<0){
		 peaksmooth2 = peaksmooth2+(0.01*diff2);
	 }
	 else {
		 peaksmooth2 = peaksmooth2+(1*diff2);
	 }


	 payload++;
/*
  	  BSP_TS_GetState(&TS_State);
  	  	  if(TS_State.touchX[0]>30 && TS_State.touchX[0]<750 && TS_State.touchY[0] > 30 && TS_State.touchY[0] < 450){
     	      X = TS_State.touchX[0];
     		  Y = TS_State.touchY[0];
     		  HAL_GPIO_TogglePin(GPIOG, LAMP4_Pin);

     		 if(X<400){
     		  Y_Left  = Y;
     		 }
     		 if(X>400){
     		  Y_Right  = Y;
     		 }
  	  	  }

  	  	left = Y_Left;
		right = Y_Right;
*/
	 payload++;

	aTxBuffer[0]= 'T';
	aTxBuffer[1]= 'E';
	aTxBuffer[2]= 'S';
	aTxBuffer[3]= 'T';

	 aTxBuffer[9]=payload;

	 if(HAL_I2C_Master_Transmit(&hi2c1, 5, aTxBuffer,10,1000)!= HAL_OK)
{
	  CODE = HAL_I2C_GetError(&hi2c1);
	  BSP_LED_On(LED2);

}
	 HAL_I2C_Master_Receive(&hi2c1, 5, aRxBuffer,10,1000);


	 //HAL_I2C_Master_Receive(&hi2c1, 5, aRxBuffer,10,1000);

	//HAL_I2C_Master_Receive(&hi2c1, 5,(uint8_t *)aRxBuffer,10,1000);

	 drawBar (395, 90,peaksmooth1,smooth1, "");
	 drawBar (415, 90,peaksmooth2,smooth2, "");

	 drawDashedLine(10, Y_Left, 350, Y_Left);
	 drawDashedLine(450, Y_Right, 790, Y_Right);

	 ENCODER_UPDATE(); //Display Encoder Values


/*==================================================*/

GUI_SetFont(&GUI_Font24B_1);

GUI_SetColor(GUI_GRAY);

}





/*********************************************************************
*
*       Public code
*
**********************************************************************
*/
/*********************************************************************
*
*       CreateWindow
*/



WM_HWIN CreateWindow(void) {
  //WM_HWIN hWin;
  WM_HWIN hParent;

 // hWin = GUI_CreateDialogBox(_aDialogCreate, GUI_COUNTOF(_aDialogCreate), _cbDialog, WM_HBKWIN, 0, 0);
  //hParent = WM_CreateWindow(0, 0, 1, 1, WM_CF_SHOW, _cbDialog, 0); //THIS IS WORKING QUITE OK!!!
  hParent = WM_CreateWindow(200, 0, 1, 1,WM_CF_SHOW, _cbDialog, 0);
 // WM_Paint(hWin);

  WM_MULTIBUF_Enable(1);

  //return hWin;
  return hParent;
}

// USER START (Optionally insert additional public code)


// USER END

/*************************** End of file ****************************/
